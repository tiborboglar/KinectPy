import os
import cv2
import sys
import copy
import logging
import subprocess
import numpy as np
import pandas as pd
import open3d as o3d
from pathlib import Path
from typing import List, Union
from utils.processing import (
    find_correspondent_frames_between_folders, scale_point_cloud,
    sort_filenames_by_timestamp, remove_files_not_synced, sync_skeleton_and_pointcloud
    )

logging.basicConfig(level=logging.INFO)


class MKVFilesProcessing(object):
    def __init__(
        self, 
        mkv_fps: List[str] = [], 
        output_dirs: List[str] = [], 
        offline_processor_fp: str = None,
        number_of_joints: int = 32
        ) -> None:
        """
        Extracts files and information from .mkv files generated by Azure Kinect devices.
        Also converts the extracted files to point clouds
    
        Args:
            mkv_fps: Input filepaths
            output_dirs: Output directories
            background_filtering: Filter background from the point cloud using a filtering method
                options: 'bounding_box', 'segmentation', None
            offline_processor_fp: Path to the offline_processor.exe installed from the Azure Kinect Extractor 
                github repository (see: https://github.com/justamad/Azure-Kinect-Extractor)
            number_of_joints: number of joints for the skeleton estimation
        """
        self.mkv_fps = mkv_fps
        self.output_dirs = output_dirs
        self.offline_processor_fp = offline_processor_fp
        self.number_of_joints = number_of_joints
        self._offline_processor_flag = True if os.path.isfile(offline_processor_fp) else False
        self._verify_setup(mkv_fps, output_dirs)
        for mkv_fp, output_dir in zip(mkv_fps, output_dirs):
            self._create_folder_structure(output_dir)


    def extract(
        self,
        color: bool = False, 
        depth: bool = False, 
        skeleton: bool = False,
        pointcloud: bool = False,
        ) -> None:
        """         
        Extract information from an MKV file generated by Azure Kinect

        Args:
            color: Flag to extract color images
            depth: Flag to extract depth images
            pointcloud: Flag to extract point clouds
        """
        for mkv_fp, output_dir in zip(self.mkv_fps, self.output_dirs):
            logging.info(f'Starting to process MKV File {mkv_fp}\n' + \
                         f'It will be saved under directory: {output_dir}\n')
            logging.info('Beware it might take some time!\n')
        
            mkv_recorder_cmd = f'{self.offline_processor_fp} {mkv_fp} --gpu' 
            if pointcloud:
                mkv_recorder_cmd += ' --pointcloud'
            if color:
                mkv_recorder_cmd += ' --rgb'
            if skeleton:
                mkv_recorder_cmd += ' --skeleton'
            if depth:
                mkv_recorder_cmd += ' --depth'
                raise NotImplementedError('Currently depth images cannot be extracted')
            logging.info(mkv_recorder_cmd)
            extraction_process = subprocess.Popen(mkv_recorder_cmd, close_fds=True)
            extraction_process.communicate()
            self._move_depth_and_color(output_dir)

        remove_files_not_synced(self.output_dirs)
        sync_skeleton_and_pointcloud(self.output_dirs, save_csv=True)

        logging.info('Extraction is done!')


    def align_skeletons(self):
        logging.info('Starting pointcloud-skeleton alignment...')
        for output_dir in self.output_dirs:

            # Load and synchronize point cloud and skeleton timestamps
            synced_skeleton = sync_skeleton_and_pointcloud(output_dir)

            # Load transformation from the registration algorithm
            device = os.path.basename(os.path.normpath(output_dir))
            if device != 'master_1':
                transformation_fp = os.path.join(self.output_dirs[0], 
                                                 f'transformation_master_{device}.npy')
                sub_transform = np.load(transformation_fp)
            else:
                sub_transform = np.identity(4)

            rotation = sub_transform[:3, :3]
            translation = sub_transform[:3, 3]

            # convert dataframe to a (n frames, k joints, 3) shaped data and then 
            transformed_skeleton = synced_skeleton.values.reshape(
                (synced_skeleton.shape[0], self.number_of_joints, 3)
                )
            transformed_skeleton = transformed_skeleton@np.linalg.inv(rotation) + translation

            # transforming it back to the (n frames, k*3) shaped data
            # columns: [joint_1x, joint_1y, joint_1z, joint_2x, ..., joint_kx, joint_ky, joint_kz]
            transformed_skeleton = transformed_skeleton.reshape(
                (synced_skeleton.shape[0], self.number_of_joints*3)
                )
            transformed_skeleton = pd.DataFrame(columns=synced_skeleton.columns, 
                                                data=transformed_skeleton,
                                                index=synced_skeleton.index)
            transformed_skeleton.to_csv(os.path.join(output_dir, 'skeleton', 'registered_positions_3d.csv'))


    def _move_depth_and_color(self, output_dir):
        """
        Move .dat and .png files to their correct folders
        """
        pcd_dir = os.path.join(output_dir, 'pointclouds')
        depths_dir = pcd_dir.replace('pointclouds', 'depths')
        color_dir = pcd_dir.replace('pointclouds', 'color')
        for filename in os.listdir(pcd_dir):
            src_fp = os.path.join(pcd_dir, filename)

            # Move to depths dir
            if filename.endswith('.dat'):
                dst_fp = os.path.join(depths_dir, filename)
                os.replace(src_fp, dst_fp)  

            # Move to color dir
            if filename.endswith('.png'):
                dst_fp = os.path.join(color_dir, filename)
                os.replace(src_fp, dst_fp)

            # Remove files named as "0_..." because they are empty
            if filename.startswith('0_'):
                if filename.endswith('.dat'):
                    os.remove(os.path.join(depths_dir, filename))
                if filename.endswith('.png'):
                    os.remove(os.path.join(color_dir, filename))


    def _create_folder_structure(self, output_dir):
            Path(os.path.join(output_dir, 'color')).mkdir(parents=True, exist_ok=True)
            Path(os.path.join(output_dir, 'filtered_pointclouds')).mkdir(parents=True, exist_ok=True)
            Path(os.path.join(output_dir, 'filtered_and_registered_pointclouds')).mkdir(parents=True, exist_ok=True)
            Path(os.path.join(output_dir, 'pointclouds')).mkdir(parents=True, exist_ok=True)
            Path(os.path.join(output_dir, 'skeleton')).mkdir(parents=True, exist_ok=True)
            Path(os.path.join(output_dir, 'depths')).mkdir(parents=True, exist_ok=True)


    def _verify_setup(self, mkv_fps, output_dirs):
        """
        Verifying if the offline processor is present in the passed path
        """
        if self._offline_processor_flag == False:
            raise FileNotFoundError('Make sure that the offline_processor.exe path is correct')
        if len(mkv_fps) != len(output_dirs) or len(mkv_fps) == 0:
            raise Exception('Make sure to give two lists, where each mkv file'
                            'has a correspondent directory to be output')
        try:
            self.mkv_to_img_converter_fp = self._find_open3d_converter()
        except Exception as e:
            logging.error(e)
            sys.exit(1)
        logging.info('Verification stage is done.\n')


    def _find_open3d_converter(self):
        """ Tries to find open3d filepath to azure_kinect_mkv_reader """
        cmd = 'python -c "import open3d as o3d; import os; print(os.path.dirname(o3d.__file__))'
        open3d_dir = subprocess.check_output(cmd).decode()
        dir_idx = open3d_dir.find('open3d') + len('open3d')
        open3d_dir = open3d_dir[:dir_idx]
        mkv_recorder_fp = os.path.join(open3d_dir, 'examples', 'reconstruction_system', 
                                       'sensors', 'azure_kinect_mkv_reader.py')
        if not os.path.isfile(mkv_recorder_fp):
            raise FileNotFoundError(mkv_recorder_fp, 
                                    'does not exist. Please verify where "azure_kinect_mkv_reader.py" is located')
        return mkv_recorder_fp